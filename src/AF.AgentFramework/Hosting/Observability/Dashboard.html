<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>AF.AgentFramework Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        body { font-family:sans-serif; margin:2em; background:#fafafa; }
        h2 { color:#333; }
        #controls { margin-bottom:0.5em; font-size:0.9em; color:#555; }
        #summary { margin-bottom:1em; }
        table { border-collapse:collapse; width:100%; margin-top:1em; background:white; }
        th,td { border:1px solid #ddd; padding:6px 8px; text-align:left; }
        th { background:#f0f0f0; }
        .warn { background:#fff6e0; }
        .alert { background:#ffe6e6; }
        .tool-error {
            /*background:#fff2f2;*/
            /*outline:1px solid #ff7070;*/
            /*outline-offset:-1px;*/
        }
        canvas { max-height:180px; margin-top:1.5em; }
        .sparkline { width:120px; height:40px; }
        .observation { margin-top:1em; font-size:0.9em; background:#fdfdfd; border:1px solid #ccc; padding:8px; border-radius:4px; }
        input[type=number] { width:80px; font-size:0.9em; padding:2px 4px; margin-left:4px; }
    </style>
</head>
<body>
<h2>AF.AgentFramework Dashboard</h2>

<div id="controls">
    Refresh every
    <input id="refreshMs" type="number" value="2000" min="100" step="100"> ms
</div>

<div id="summary">Loading‚Ä¶</div>

<canvas id="throughputChart"></canvas>

<table id="agents">
    <tr>
        <th>Agent</th>
        <th>Queue</th>
        <th>Œî/s</th>
        <th>Avg ms</th>
        <th>Util%</th>
        <th>Rej</th>
        <th>Handled</th>
        <th>Tools</th>
        <th>Errors</th>
        <th>Last Tool</th>
        <th>Status</th>
    </tr>

</table>

<div id="observations" class="observation"></div>

<script>
    const throughputCtx = document.getElementById('throughputChart').getContext('2d');
    const throughputChart = new Chart(throughputCtx, {
        type: 'line',
        data: {
            labels: [],
            datasets: [{ label: 'Throughput (items/s)', data: [], borderColor:'#512BD4', tension:0.2 }]
        },
        options: { animation:false, scales:{ y:{ beginAtZero:true } } }
    });

    const history = {}; // { agentId: {queue:[], util:[]} }

    async function refresh() {
        try {
            const r = await fetch('/af/snapshot');
            const j = await r.json();

            // --- summary ---
            document.getElementById('summary').textContent =
                `Agents: ${j.totalAgents} | Running: ${j.runningAgents} | Queued: ${j.queuedItems} | Handled: ${j.totalHandledItems} | Rejected: ${j.rejectedItems} | Throughput: ${j.throughputPerSecond.toFixed(2)}/s | Workers: ${j.workerCount}` + (j.workerCount > 1 ? " ‚öôÔ∏è" : "");

            // --- throughput trend ---
            const ts = new Date(j.timestamp).toLocaleTimeString();
            throughputChart.data.labels.push(ts);
            throughputChart.data.datasets[0].data.push(j.throughputPerSecond);
            if (throughputChart.data.labels.length > 25) {
                throughputChart.data.labels.shift();
                throughputChart.data.datasets[0].data.shift();
            }
            throughputChart.update();

            // --- agents table ---
            const rows = j.agents.map(a => {
                const h = history[a.id] ??= { queue: [], util: [] };
                h.queue.push(a.queueLength);
                h.util.push(a.utilizationPercent);
                if (h.queue.length > 25) { h.queue.shift(); h.util.shift(); }

                let cls = '';
                if (a.queueLength >= 256) cls = 'alert';
                else if (a.queueLength >= 128) cls = 'warn';

                // subtle dimming for idle agents
                const opacity = a.totalHandled === 0 ? 0.5 : 1.0;
                const state = a.isRunning ? 'üü¢' : '‚ö™Ô∏è';

                // --- extract tool metrics safely ---
                const m = a.metrics || {};
                const totalTools = m["Tools.TotalInvoked"] ?? 0;
                const toolErrors = m["Tools.Errors"] ?? 0;
                const lastTool = m["Tools.LastTool"] ?? "‚Äì";

                return `<tr class="${cls}" style="opacity:${opacity}">
                    <td>${a.id}</td>
                    <td>${a.queueLength}</td>
                    <td>${a.queueGrowthRate.toFixed(1)}</td>
                    <td>${a.avgExecutionMs.toFixed(1)}</td>
                    <td>${a.utilizationPercent.toFixed(0)}</td>
                    <td>${a.rejected}</td>
                    <td>${a.totalHandled}</td>
                    <td>${totalTools}</td>
                        <td class="${toolErrors > 0 ? 'tool-error' : ''}">${toolErrors}</td>
                    <td style="color:#777;font-style:italic;">${lastTool}</td>
                    <td>${state}</td>
                </tr>`;
            }).join('');

            document.getElementById('agents').innerHTML =
                `<tr>
                    <th>Agent</th>
                    <th>Queue</th>
                    <th>Œî/s</th>
                    <th>Avg ms</th>
                    <th>Util%</th>
                    <th>Rej</th>
                    <th>Handled</th>
                    <th>Tools</th>
                    <th>Errors</th>
                    <th>Last Tool</th>
                    <th>Status</th>
                </tr>${rows}`;

            // --- observations ---
            const obs = [];
            j.agents.forEach(a => {
                const m = a.metrics || {};
                const toolErrors = m["Tools.Errors"] ?? 0;
                if (a.queueLength > 200) obs.push(`‚ö†Ô∏è ${a.id} overloaded (${a.queueLength} queued)`);
                if (a.rejected > 0) obs.push(`‚ùå ${a.id} dropping work (${a.rejected} rejected)`);
                if (a.utilizationPercent < 10 && a.queueLength === 0) obs.push(`‚ÑπÔ∏è ${a.id} mostly idle`);
                if (toolErrors > 0) obs.push(`‚ùå ${a.id} tool errors (${toolErrors})`);
            });
            document.getElementById('observations').innerHTML =
                obs.length ? obs.join('<br>') : '‚úÖ All agents stable';

        } catch (err) {
            console.error(err);
            document.getElementById('summary').textContent = 'Error fetching snapshot';
        }
    }

    // --- refresh control ---
    const input = document.getElementById('refreshMs');
    const saved = localStorage.getItem('af_refresh_ms');
    if (saved) input.value = saved;

    let refreshMs = Math.max(100, parseInt(input.value, 10) || 2000);
    let timer = setInterval(refresh, refreshMs);

    input.addEventListener('change', e => {
        const val = Math.max(100, parseInt(e.target.value, 10) || 2000);
        e.target.value = val;
        localStorage.setItem('af_refresh_ms', val);
        clearInterval(timer);
        refreshMs = val;
        timer = setInterval(refresh, refreshMs);
    });

    refresh();
</script>
</body>
</html>
